---
layout: post
title: Consensus in Distributed systems
description: This post highlights the challenges in achieving consensus in a distributed environment. This post describes many use cases and variations of consensus. Safety and liveliness properties w.r.t distributed consensus. Later various consensus protocols are discussed in detail.
---

<h1>Atomic distributed transaction</h1>

Transaction is a set of operations which are either executed or not executed at all. In other words the state of the system is a result of the complete
execution or no execution at all. Achieving transactional behaviour in distributed systems is not quite trivial. The problem becomes more interesting when we are dealing with asynchronous distributed systems where the assumptions about time and order of events in the system does not hold. Even in Synchronous distributed systems, where are there are strong guarantees about clock and order of events things can go wrong, if not handled properly.<i>[More about this later]</i> The set of operations [part of a transaction] are executed across multiple hosts so that the final state of all the hosts are same as a result of execution of the transaction. This is also termed as Distributed Atomic Transactions. It is a variation of consensus problem where a set of hosts are agreeing on a value. In this case set of nodes are agreeing on whether to commit/abort a transaction.([Linearisable Consistency](http://www.bailis.org/blog/linearizability-versus-serializability/)/ Light weight transactions in cassandra )
Distributed transactions, state machine replication, Leader Election, are all the variations of the same problem "Consensus".

<h1>Consensus (Single vs ,multi value)</h1>

The problem is as simple as agreeing on a single value amongst a set of processes.I wish it was as "simple" as I have quoted. It becomes more interesting when you add a little bit of chaos where the processes can be faulty or fail while the consensus is being achieved.<b>The processes must somehow put forth their candidate values, communicate with one another, and agree on a single [consensus](https://en.wikipedia.org/wiki/Consensus_(computer_science)) value.</b>
There are many distributed systems where electing a leader is a trivial requirement. But the question is for electing a leader why would you need consensus.
The reason is to avoid multiple leaders in the system. So the consensus ensures that there is only one leader selected amongst a set of nodes. Having multiple leaders can lead to serious issues in distributed systems like [split brain](https://www.quora.com/What-is-split-brain-in-distributed-systems).<br><br>
The other variation of consensus is Replicated State Machine or multi value consensus, where in a set of machines should have execute the same sequence of operations to reach the same state. Here a set of nodes agree on multiple values but the order of accepted values is important.
I would also like to quote another sibling of Consensus, "atomic_broadcast" which is the ability to deliver messages in a network reliably and in a total order to all nodes.Messages here are delivered “atomically”: every message is either delivered to all processes or to none of them and, if the message is delivered, every other message is ordered before or after this message.

<h1>Set the goals right before starting</h1>

Distributed systems are all about handling failure scenarios, guarantees and assumptions.Lets set these right before getting into water.

> Safety and liveliness

All family of consensus protocol has to adhere to safety and liveliness.

<b>The safety property ensures that only one value is chosen. The liveliness property ensures that a value is chosen eventually.</b>
But I personally like the below definition

{% highlight text %}

"Safety properties say that nothing bad will ever happen".
"Liveliness properties say that something good will eventually happen".

{% endhighlight %}

> Agreement, Validity and Termination

{% highlight text %}

  1. Agreement is pretty straight forward where all N nodes agree on a single value.
  2. Validity ensures the validity of the agreement. i.e. only the value that is proposed should be agreed.
  3. Termination ensures that all nodes eventually agree.

{% endhighlight %}

For example. if all nodes always agree on a default configured value, Even though agreement property is met , Validity is not met.</i>

> Assumptions

Following are the assumptions related to failures that can happen while the consensus is being achieved.

  1.  failure of nodes,
  2.  delay in messages,
  3.  lost messages
  4.  Value must me decided as long as the majority of nodes are available

There is a separate class of failure called "Byzantine Failure". The assumption we have set is that none of the consensus protocols have this mode of failure.
There is a nice post on why consensus cannot be achieved in a system with one faulty process in asynchronous environment. [link](http://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/).

> Actors in Consensus

Proposer: This actor is responsible for proposing a value. He is also responsible for handling client requests.<br>
Acceptors: This actor responds to proposers message. Its response represents votes for the consensus. Stores the chosen value. Discovers the chosen value.

<b>A node can be a proposer, acceptor or even both.</b>In all the below example we will assume that node is both proposer and acceptor.

<h1>Consensus protocols</h1>

> 1.1 Simplest Consensus protocol Single Acceptor

We can have a single acceptor decide/chose the value amongst a group of nodes. The problem with this approach is if the acceptor node dies immediately after receiving the proposed value, then we can no longer decide the value. Hence it is required for the consensus to be reached when the majority of nodes are available.

> 1.2 Quorum number of Acceptors

To solve the previous problem we can have multiple acceptors in the cluster and have them accept values proposed by the proposers. However the problem with this approach is it is possible that different acceptors might accept different values during multiple proposals depending upon the order in which they receive the proposals. In the example below it is possible that servers a1,a2 might accept red, while a3,a4 might accept blue and a5 might accept green.
This kind of also gives an intuition and reasoning to claim that we need more than one rounds to reach proper consensus.

![Image1]({{ site.url }}/assets/pax/pax1.png)


> 1.3 Acceptors Accepting every value it receives

Note that just because a value is received does not mean it is chosen. A value is chosen only if a majority of Acceptors accept the same value. So after receiving a value , the acceptor might ask permission from majority of nodes whether to accept or not. IF majority is met then that value is accepted.
In the below example, "red" is accepted after majority of nodes a1,a2,a3 accepted it.However, when there is another proposal for "blue", again majority is met, resulting in accepting "blue". This violates the safety property.

![Image1]({{ site.url }}/assets/pax/pax2.png)

> 1.4 2-phase protocol

The problem with above method is that the acceptors accept every value they receive. If we can avoid this by ensuring that once the value is chosen, the chosen value is reproposed by the new proposer. In the above case , a5 must check to see if there is a value chosen already before proposing "blue" .
Since "red" is already chosen, a5 must propose "red" again.

Another way to look at 2 phase protocol is that there are 2 phases.
  1.  propose phase
  2.  commit/abort phase
