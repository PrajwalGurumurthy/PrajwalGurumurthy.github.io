---
layout: post
title: Consensus in Distributed systems
description: This post highlights the challenges in achieving consensus in a distributed environment. This post describes many use cases and variations of consensus. Safety and liveliness properties w.r.t distributed consensus. Later various consensus protocols are discussed in detail.
---

> Atomic distributed transaction

Transaction is a set of operations which are either executed or not executed at all. In other words the state of the system is a result of the complete
execution or no execution at all. Achieving transactional behaviour in distributed systems is not quite trivial. The problem becomes more interesting when we are dealing with asynchronous distributed systems where the assumptions about time and order of events in the system does not hold. Even in Synchronous distributed systems, where are there are strong guarantees about clock and order of events things can go wrong, if not handled properly.<i>[More about this later]</i> The set of operations [part of a transaction] are executed across multiple hosts so that the final state of all the hosts are same as a result of execution of the transaction. This is also termed as Distributed Atomic Transactions. It is a variation of consensus problem where a set of hosts are agreeing on a value. In this case set of nodes are agreeing on whether to commit/abort a transaction.([Linearisable Consistency](http://www.bailis.org/blog/linearizability-versus-serializability/)/ Light weight transactions in cassandra )
Distributed transactions, state machine replication, Leader Election, are all the variations of the same problem "Consensus".

> Consensus (Single vs ,multi value)

The problem is as simple as agreeing on a single value amongst a set of processes.I wish it was as "simple" as I have quoted. It becomes more interesting when you add a little bit of chaos where the processes can be faulty or fail while the consensus is being achieved.<b>The processes must somehow put forth their candidate values, communicate with one another, and agree on a single [consensus](https://en.wikipedia.org/wiki/Consensus_(computer_science)) value.</b>
There are many distributed systems where electing a leader is a trivial requirement. But the question is for electing a leader why would you need consensus.
The reason is to avoid multiple leaders in the system. So the consensus ensures that there is only one leader selected amongst a set of nodes. Having multiple leaders can lead to serious issues in distributed systems like [split brain](https://www.quora.com/What-is-split-brain-in-distributed-systems).<br><br>
The other variation of consensus is Replicated State Machine or multi value consensus, where in a set of machines should have execute the same sequence of operations to reach the same state. Here a set of nodes agree on multiple values but the order of accepted values is important.
I would also like to quote another sibling of Consensus, "atomic_broadcast" which is the ability to deliver messages in a network reliably and in a total order to all nodes.Messages here are delivered “atomically”: every message is either delivered to all processes or to none of them and, if the message is delivered, every other message is ordered before or after this message.

<h1>Set the goals right before starting</h1>

Distributed systems are all about handling failure scenarios, guarantees and assumptions.Lets set these right before getting into water.

> Safety and liveliness

All family of consensus protocol has to adhere to safety and liveliness.

<b>The safety property ensures that only one value is chosen. The liveliness property ensures that a value is chosen eventually.</b>
But I personally like the below definition

{% highlight text %}

"Safety properties say that nothing bad will ever happen".
"Liveliness properties say that something good will eventually happen".

{% endhighlight %}

> Agreement, Validity and Termination

{% highlight text %}

  1. Agreement is pretty straight forward where all N nodes agree on a single value.
  2. Validity ensures the validity of the agreement. i.e. only the value that is proposed should be agreed.
        For example. if all nodes always agree on a default configured value, Even though agreement property is met , Validity is not met.</i>
  3. Termination ensures that all nodes eventually agree.

{% endhighlight %}

> Assumptions

Following are the assumptions related to failures that can happen while the consensus is being achieved.
  1.  failure of nodes,
  2.  delay in messages,
  3.  lost messages

There is a separate class of failure called "Byzantine Failure". The assumption we have set is that none of the consensus protocols have this mode of failure.
There is a nice post on why consensus cannot be achieved in a system with one faulty process in asynchronous environment. [link](http://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/).

> Actors in Consensus

Proposer: This actor is responsible for proposing a value. He is also responsible for handling client requests.<br>
Acceptors: This actor responds to proposers message. Its response represents votes for the consensus. Stores the chosen value. Discovers the chosen value.

A node can be a proposer, acceptor or eve both.

> Simplest Consensus protocol
